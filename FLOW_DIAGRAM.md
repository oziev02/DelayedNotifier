# Упрощенная схема потока выполнения

## 📥 Создание уведомления (POST /api/notify)

```
┌──────────────┐
│   Клиент     │
│  (Браузер/   │
│   Postman)   │
└──────┬───────┘
       │ POST /api/notify
       │ {user_id, channel, recipient, subject, message, scheduled_at}
       ↓
┌─────────────────────────────────────┐
│  cmd/server/main.go                 │
│  Gin Router (строка 90)             │
│  api.POST("/notify", ...)           │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  internal/delivery/http/handler.go  │
│  Handler.CreateNotification()       │
│  - Парсит JSON                      │
│  - Вызывает usecase                 │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  internal/usecase/                  │
│  notification_usecase.go            │
│  NotificationUsecase.Create()       │
│                                     │
│  1. Валидация времени               │
│  2. Создание Notification с ID      │
│  3. Сохранение в хранилище          │
│  4. Кэширование                     │
│  5. Публикация в очередь            │
└──────────────┬──────────────────────┘
               │
       ┌───────┴────────┐
       │                │
       ↓                ↓
┌──────────────┐  ┌──────────────┐
│ InMemory     │  │ Redis Cache  │
│ Storage      │  │ (опционально)│
│ (map[string] │  │              │
│ Notification)│  └──────────────┘
└──────────────┘
       │
       ↓
┌─────────────────────────────────────┐
│  internal/repository/queue/         │
│  rabbitmq_queue.go                  │
│  RabbitMQQueue.Publish()            │
│  - Сериализация в JSON              │
│  - Отправка в RabbitMQ              │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  RabbitMQ                           │
│  Очередь: "notifications"           │
└─────────────────────────────────────┘
               │
               │ Уведомление готово к обработке
               ↓
       [ Возврат HTTP 201 Created ]
```

---

## ⚙️ Обработка уведомления (Worker)

```
┌─────────────────────────────────────┐
│  cmd/server/main.go                 │
│  Запуск Worker (строка 66)          │
│  go workerUsecase.Start()           │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  internal/usecase/                  │
│  worker_usecase.go                  │
│  WorkerUsecase.Start()              │
│  - Подписка на канал из RabbitMQ    │
│  - Бесконечный цикл обработки       │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  internal/repository/queue/         │
│  rabbitmq_queue.go                  │
│  RabbitMQQueue.Consume()            │
│                                     │
│  - Читает из RabbitMQ               │
│  - Проверяет время отправки         │
│    * Если рано → возврат в очередь  │
│    * Если время пришло → в канал    │
└──────────────┬──────────────────────┘
               ↓
       Уведомление в канале
               ↓
┌─────────────────────────────────────┐
│  internal/usecase/                  │
│  worker_usecase.go                  │
│  processNotification()              │
│  (выполняется в горутине)           │
│                                     │
│  1. Проверка отмены                 │
│     (чтение из хранилища)           │
│  2. Повторная проверка времени      │
│  3. Отправка через SenderManager    │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  internal/repository/sender/        │
│  sender_manager.go                  │
│  SenderManager.Send()               │
│                                     │
│  - Перебирает отправителей          │
│  - Находит подходящего              │
│    (Supports(channel))              │
└──────────────┬──────────────────────┘
               ↓
       ┌───────┴────────┐
       │                │
       ↓                ↓
┌──────────────┐  ┌──────────────┐
│ EmailSender  │  │ Telegram     │
│ .Send()      │  │ Sender       │
│              │  │ .Send()      │
│ [Логирование]│  │ [Логирование]│
└──────────────┘  └──────────────┘
       │                │
       └────────┬───────┘
                │
         ┌──────┴──────┐
         │             │
    Успех         Ошибка
         │             │
         ↓             ↓
┌──────────────┐ ┌──────────────┐
│ Обновление   │ │ Retry        │
│ статуса      │ │ механизм     │
│ на "sent"    │ │              │
│              │ │ - Увеличение │
│ - Storage    │ │   счетчика   │
│ - Cache      │ │ - Задержка   │
│              │ │   2^count сек│
│              │ │ - Повторная  │
│              │ │   публикация │
└──────────────┘ └──────────────┘
```

---

## 🔍 Получение уведомления (GET /api/notify/:id)

```
┌──────────────┐
│   Клиент     │
└──────┬───────┘
       │ GET /api/notify/:id
       ↓
┌─────────────────────────────────────┐
│  Handler.GetNotification()          │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  NotificationUsecase.GetByID()      │
│                                     │
│  1. Проверка кэша (Redis)           │
│     └─→ Если найдено: возврат       │
│                                     │
│  2. Если нет в кэше:                │
│     └─→ Чтение из хранилища         │
│                                     │
│  3. Обновление кэша                 │
│                                     │
│  4. Возврат уведомления             │
└──────────────┬──────────────────────┘
               ↓
       HTTP 200 OK + JSON
```

---

## ❌ Отмена уведомления (DELETE /api/notify/:id)

```
┌──────────────┐
│   Клиент     │
└──────┬───────┘
       │ DELETE /api/notify/:id
       ↓
┌─────────────────────────────────────┐
│  Handler.DeleteNotification()       │
└──────────────┬──────────────────────┘
               ↓
┌─────────────────────────────────────┐
│  NotificationUsecase.Cancel()       │
│                                     │
│  1. Получение уведомления           │
│  2. Проверка статуса                │
│     (нельзя отменить отправленное)  │
│  3. Обновление статуса на           │
│     "cancelled"                     │
│  4. Удаление из кэша                │
│  5. Удаление из хранилища           │
└──────────────┬──────────────────────┘
               ↓
       HTTP 200 OK
```

---

## 🔄 Retry механизм (при ошибке отправки)

```
Ошибка отправки
       ↓
┌─────────────────────────────────────┐
│  handleRetry()                      │
│                                     │
│  1. Проверка количества попыток     │
│     (maxRetries = 5)                │
│                                     │
│  2. Если превышен лимит:            │
│     → Статус = "failed"             │
│     → Завершение                    │
│                                     │
│  3. Если попытки есть:              │
│     → IncrementRetryCount()         │
│     → Вычисление задержки:          │
│       2^retryCount секунд           │
│       (1 сек, 2 сек, 4 сек, ...)   │
│     → Обновление ScheduledAt        │
│     → Публикация в очередь          │
└──────────────┬──────────────────────┘
               ↓
       Уведомление снова в очереди
               ↓
       [ Повторная обработка через Worker ]
```

---

## 🏗️ Структура компонентов при старте

```
main()
  │
  ├─→ config.Load() ──────────────→ Конфигурация из ENV
  │
  ├─→ InMemoryStorage ────────────→ Хранилище (map)
  │
  ├─→ RedisCache / NoOpCache ─────→ Кэш
  │
  ├─→ RabbitMQQueue ──────────────→ Очередь
  │
  ├─→ EmailSender ──────────────────┐
  │                                  ├─→ SenderManager
  ├─→ TelegramSender ───────────────┘
  │
  ├─→ NotificationUsecase ──────────→ Usecase для API
  │   ├──→ NotificationRepository
  │   ├──→ CacheRepository
  │   └──→ QueueRepository
  │
  ├─→ WorkerUsecase ────────────────→ Usecase для Worker
  │   ├──→ QueueRepository
  │   ├──→ NotificationRepository
  │   ├──→ CacheRepository
  │   └──→ SenderManager
  │
  ├─→ HTTP Handler ─────────────────→ Обработчик HTTP
  │   └──→ NotificationUsecase
  │
  ├─→ Gin Router ───────────────────→ Маршрутизация
  │   ├──→ GET / → HTML страница
  │   └──→ /api/* → Handler методы
  │
  └─→ HTTP Server ──────────────────→ Запуск сервера
      │
      └─→ Worker (goroutine) ────────→ Фоновая обработка
```

---

## 📊 Временная линия обработки

```
T0: Клиент → POST /api/notify
           │
           ├─→ Handler.CreateNotification()
           │
T1:        ├─→ Usecase.Create()
           │   ├─→ Валидация ✓
           │   ├─→ Создание Notification
           │   ├─→ Сохранение в Storage
           │   ├─→ Кэширование
           │   └─→ Публикация в RabbitMQ
           │
T2:        └─→ HTTP 201 Created ← [Ответ клиенту]
           │
           └─→ Уведомление в очереди RabbitMQ
               
T3:        Worker читает из очереди
           │
           ├─→ Проверка времени (ScheduledAt)
           │   ├─→ Если рано: возврат в очередь
           │   └─→ Если время пришло: обработка
           │
T4:        ├─→ processNotification()
           │   ├─→ Проверка отмены
           │   ├─→ SenderManager.Send()
           │   │   └─→ EmailSender или TelegramSender
           │   │
           │   ├─→ Успех:
           │   │   ├─→ Статус = "sent"
           │   │   └─→ Обновление Storage и Cache
           │   │
           │   └─→ Ошибка:
           │       └─→ Retry механизм
           │           ├─→ Задержка 2^count секунд
           │           └─→ Повторная публикация в очередь
           │
T5:        [Обработка завершена]
```

---

## 🎯 Ключевые моменты

1. **HTTP запрос и ответ синхронные** - клиент получает ответ сразу после создания уведомления
2. **Обработка асинхронная** - Worker работает независимо в отдельной горутине
3. **Очередь как буфер** - RabbitMQ хранит уведомления до момента обработки
4. **Кэш для быстрого доступа** - Redis ускоряет чтение (опционально)
5. **Хранилище как источник истины** - InMemoryStorage хранит все уведомления
6. **Retry с задержкой** - Экспоненциальная задержка при ошибках
7. **Graceful shutdown** - Корректное завершение работы всех компонентов

